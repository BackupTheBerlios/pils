#!/usr/bin/env python

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# pils - Python Irc Log Stats ( http://pils.berlios.de )
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
#
# a tiny python script to analyze logfiles of irc-conversations and
# generate corresponding html-output
#
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
#
# FEATURES:
#   - input is currently limited to dircproxy
#   - the output's layout is hard-coded
#   - the shown plugins are not selectable yet
#
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
#
# TODO:
#   - modularization:
#     split up functionality into seperate units for more flexibility
#     and a cleaner program structure
#     ( e.g. input, analyzation and output )
#   - optimization:
#     perfomance enhancements
#     ( e.g. avoid looping over large sequences )
#   - enhancements:
#     adding functionality
#     ( e.g. caching or templates )
#   - distutils setup
#
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# (c) 2003-2004 - Nikolaus Schlemm
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #


# temporarily taken out
## try to get some more performance
#try:
#    import psyco
#    psyco.full()
#except:
#    pass


# the necessary imports
import os, re, sys, math, time, cPickle, string, random, calendar

from pils.pilsImage import nickActivity

# define arrays for the calendar names, so they can easily be tranlated
weekdayNames = ( "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun" )
monthNames   = ( "Jan", "Feb", "Mar", "Apr", "May", "Jun",
                 "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" )

def monthName2Number( m ):
    """resolve a month's name to its numerical represantation
    """
    for i in range( 12 ):
        if monthNames[ i ] == m:
            return str( i+1 )

def formatMyTime( t ):
    """resolve a "yyyymmddhhmmss"-timestamp to a nice date-format
    """
    return """
%s %s %s %s:%s:%s %s
""" % ( weekdayNames[ calendar.weekday( int( t[:4] ),
                                        int( t[4:6] ),
                                        int( t[6:8] )
                                      )
                    ],
        monthNames[ int( t[4:6] )-1 ],
        t[6:8],
        t[8:10],
        t[10:12],
        t[12:],
        t[:4]
      )

def myTimeToTuple( t ):
    return ( int( t[:4] ), int( t[4:6] ), int( t[6:8] ),
             int( t[8:10] ), int( t[10:12] ), int( t[12:] )
           )

def daysDiffMyTime( t1, t2 ):
    if t1 < t2:
        return daysDiffMyTime( t2, t1 )
    else:
        t1 = calendar.timegm( myTimeToTuple( t1 ) )
        t2 = calendar.timegm( myTimeToTuple( t2 ) )
        return int( math.ceil( ( t1 - t2 ) / 86400.0 ) )

def countWords( s ):
    w = 0
    s = s.strip()
    while s.count( ' ' ) > 0:
        w += 1
        s = s[ s.index( ' ' ): ].strip()
    if len( s ) > 0:
        w += 1
    return w

def splitWords( str ):
    minLength = 3
    words     = []
    str       += " "
    w         = ""
    for i in range( len( str ) ):
        if str[ i ].isalnum():
            w += str[ i ]
        else:
            if len( w ) > minLength and w != "":
                words.append( w.lower() )
            w = ""
    return words

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

class ircLog:
    """ the base class for an irc log-analyzer
    """

    # if you need to filter out any nicks, put them in this list
    ignoredNicks = ()

    def __init__( self, channel, network, generator, path=None ):
        """the constructor - mostly setting up instance variables
        """
        self.startTime = time.time()
        self.channel   = channel
        self.network   = network
        self.generator = generator
        self.nicks     = []
        self.byNick    = {}
        self.byIP      = {}
        self.byCountry = {}
        self.byMinute  = {}
        self.byHour    = {}
        self.byDay     = {}
        self.byWeekday = {}
        self.byMonth   = {}
        self.byYear    = {}
        self.urls      = {}
        self.patterns  = {}
        self.nickRefs  = {}
        self.questions = {}
        self.yelling   = {}
        self.shouting  = {}
        self.happy     = {}
        self.sad       = {}
        self.words     = {}
        # initialise the internal variables
        self.numOfMsgs = 0
        self.firstMsg  = 0
        self.lastMsg   = 0
        self.initMinutes()
        self.initHours()
        self.initDays()
        self.initMonths()
        self.initWeekdays()
        self.initPatterns()
        # optionally parse in a logfile
        if path and os.path.exists( path ) and os.path.isfile( path ):
            self.path  = path
            self.parse()

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def initMinutes( self ):
        """initialise the byMinute-stats
        """
        for m in range( 60 ):
            self.byMinute[ m ] = 0

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def initHours( self ):
        """initialise the byHour-stats
        """
        for h in range( 24 ):
            self.byHour[ h ] = 0

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def initDays( self ):
        """initialise the byDay-stats
        """
        for d in range( 31 ):
            self.byDay[ d ] = 0

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def initMonths( self ):
        """initialise the byMonth-stats
        """
        for m in range( 12 ):
            self.byMonth[ m ] = 0

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def initWeekdays( self ):
        """initialise the byWeekday-stats
        """
        for d in range( 7 ):
            self.byWeekday[ d ] = 0

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def initPatterns( self ):
        """initialise the regex-patterns
        """
        self.patterns[ 'url' ]  = re.compile( "(([a-z]+://)|(www\.))([a-z0-9\-]+\.)+[a-z0-9\-]+((\.|/)\S+)*",
                                              re.IGNORECASE
                                            )
        self.patterns[ 'word' ] = re.compile( "[a-z0-9]{5,}",
                                              re.IGNORECASE
                                            )

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def loadStats( self, filename ):
        fh = open( filename, 'r' )
        dump = cPickle.load( fh )
        fh.close()
        self.channel   = dump[ 'channel' ]
        self.network   = dump[ 'network' ]
        self.generator = dump[ 'generator' ]
        self.nicks     = dump[ 'nicks' ]
        self.byNick    = dump[ 'byNick' ]
        self.byIP      = dump[ 'byIP' ]
        self.byCountry = dump[ 'byCountry' ]
        self.byMinute  = dump[ 'byMinute' ]
        self.byHour    = dump[ 'byHour' ]
        self.byDay     = dump[ 'byDay' ]
        self.byWeekday = dump[ 'byWeekday' ]
        self.byMonth   = dump[ 'byMonth' ]
        self.byYear    = dump[ 'byYear' ]
        self.urls      = dump[ 'urls' ]
        self.nickRefs  = dump[ 'nickRefs' ]
        self.questions = dump[ 'questions' ]
        self.yelling   = dump[ 'yelling' ]
        self.shouting  = dump[ 'shouting' ]
        self.happy     = dump[ 'happy' ]
        self.sad       = dump[ 'sad' ]
        self.words     = dump[ 'words' ]
        self.numOfMsgs = dump[ 'numOfMsgs' ]
        self.firstMsg  = dump[ 'firstMsg' ]
        self.lastMsg   = dump[ 'lastMsg' ]

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def dumpStats( self, filename ):
        fh = open( filename, 'w' )
        cPickle.dump( { 'channel'  : self.channel,
                        'network'  : self.network,
                        'generator': self.generator,
                        'nicks'    : self.nicks,
                        'byNick'   : self.byNick,
                        'byIP'     : self.byIP,
                        'byCountry': self.byCountry,
                        'byMinute' : self.byMinute,
                        'byHour'   : self.byHour,
                        'byDay'    : self.byDay,
                        'byWeekday': self.byWeekday,
                        'byMonth'  : self.byMonth,
                        'byYear'   : self.byYear,
                        'urls'     : self.urls,
                        'nickRefs' : self.nickRefs,
                        'questions': self.questions,
                        'yelling'  : self.yelling,
                        'shouting' : self.shouting,
                        'happy'    : self.happy,
                        'sad'      : self.sad,
                        'words'    : self.words,
                        'numOfMsgs': self.numOfMsgs,
                        'firstMsg' : self.firstMsg,
                        'lastMsg'  : self.lastMsg
                      },
                      fh,
                      cPickle.HIGHEST_PROTOCOL )
        fh.close()

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def parse( self ):
        """read the logfile and analyze its contents
        """
        dumpDate = 0
        dumpFile = '%s.dump' % self.channel
        if os.path.exists( dumpFile ):
            self.loadStats( dumpFile )
            dumpDate = self.lastMsg
        fh = open( self.path, 'r' )
        lines = fh.readlines()
        fh.close()
        # split lines
        for l in lines:
            # ignore comments
            if l.startswith( "@" ):
                date, msg = l[ 1: ].split( " ", 1 )
                try:
                    date = int( date )
                    date = time.gmtime( date )
                except:
                    break
                day     = date[ 2 ]
                month   = date[ 1 ]
                year    = date[ 0 ]
                hour    = date[ 3 ]
                minute  = date[ 4 ]
                second  = date[ 5 ]
                weekday = calendar.weekday( int( year ),
                                            int( month ),
                                            int( day ) )
                if len( str( month ) ) < 2:
                    month = "0%s" % month
                if len( str( day ) ) < 2:
                    day = "0%s" % day
                if len( str( hour ) ) < 2:
                    hour = "0%s" % hour
                if len( str( minute ) ) < 2:
                    minute = "0%s" % minute
                if len( str( second ) ) < 2:
                    second = "0%s" % second
                date = "%s%s%s%s%s%s" % ( year, month, day,
                                          hour, minute, second )
                if date > dumpDate:
                    if self.firstMsg == 0 or self.firstMsg > date:
                        self.firstMsg = date
                    if self.lastMsg == 0 or self.lastMsg < date:
                        self.lastMsg = date
                    # a conversational message
                    if msg[0] == "<":
                        nick, msg = msg[1:].split( ">", 1 )
                        nick, ident = nick.split( "!", 1 )
                        self.log( nick, msg, date )
                        self.incWeekday( weekday )
                    # an action
                    elif msg[0] == "[":
                        pass
                    # a server message
                    elif msg[0] == "-":
                        pass
        self.dumpStats( dumpFile )
        # remove them after writing the dump-file
        self.removeIgnoredNicks()

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def removeIgnoredNicks( self ):
        for n in self.ignoredNicks:
            if n in self.nicks:
                self.nicks.remove( n )
            if self.byNick.has_key( n ):
                del( self.byNick[ n ] )
            if self.nickRefs.has_key( n ):
                del( self.nickRefs[ n ] )
            if self.questions.has_key( n ):
                del( self.questions[ n ] )
            if self.shouting.has_key( n ):
                del( self.shouting[ n ] )
            if self.yelling.has_key( n ):
                del( self.yelling[ n ] )
            if self.happy.has_key( n ):
                del( self.happy[ n ] )
            if self.sad.has_key( n ):
                del( self.sad[ n ] )

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def log( self, who, what, when ):
        """log one message
        """
        if not who in self.nicks:
            self.nicks.append( who )
        if not self.byNick.has_key( who ):
            self.byNick[ who ] = {}
        if what.count( "?" ) > 0:
            if not self.questions.has_key( who ):
                self.questions[ who ] = 0
            self.questions[ who ] += 1
        if what.count( "!" ) > 0:
            if not self.yelling.has_key( who ):
                self.yelling[ who ] = 0
            self.yelling[ who ] += 1
        if what.isupper():
            if not self.shouting.has_key( who ):
                self.shouting[ who ] = 0
            self.shouting[ who ] += 1
        if what.count( ":)" ) > 0:
            if not self.happy.has_key( who ):
                self.happy[ who ] = 0
            self.happy[ who ] += 1
        if what.count( ":(" ) > 0:
            if not self.sad.has_key( who ):
                self.sad[ who ] = 0
            self.sad[ who ] += 1
        while self.byNick[ who ].has_key( when ):
            when = "%s%s" % ( when[ :-6 ],
                              string.zfill( ( int( when[ -6: ] ) + 1 ),
                                            6
                                          )
                            )
        self.logNickRefs( who, what, when )
        self.logWords( who, what, when )
        self.byNick[ who ][ when ] = self.logUrls( who, what, when )
        self.incMinute( when[ -4:-2 ] )
        self.incHour(   when[ -6:-4 ] )
        self.incDay(    when[  6: 8 ] )
        self.incMonth(  when[  4: 6 ] )
        self.incYear(   when[   : 4 ] )
        self.numOfMsgs += 1

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def logNickRefs( self, who, what, when ):
        """log the referenced nick in a message
           this one DEFINETELY needs serious improvement!!!
        """
        for n in self.nicks:
            if n != who:
#                n = n.replace( '[', '\[' ).replace( ']', '\]' ).replace( '|', '\|' )
#                if not self.patterns[ 'nicks' ].has_key( n ):
#                    self.patterns[ 'nicks' ][ n ] = re.compile( n, re.IGNORECASE )
#                cnt = len( self.patterns[ 'nicks' ][ n ].findall( what ) )
                cnt = what.count( n )
                if cnt > 0:
                    if self.nickRefs.has_key( n ):
                        cnt += self.nickRefs[ n ][ 'count' ]
                    self.nickRefs[ n ] = { 'count': cnt,
                                           'nick' : who,
                                           'time' : when
                                         }

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def logUrls( self, who, what, when ):
        """log the urls mentioned in a message and link them
        """
        m = self.patterns[ 'url' ].search( what )
        if m:
            cnt = 1
            url =  m.group()
            if url.startswith( 'www' ):
                url = "http://%s" % url
            if self.urls.has_key( url ):
                cnt += self.urls[ url ][ 'count' ]
            self.urls[ url ] = { 'count': cnt,
                                 'nick' : who,
                                 'time' : when
                               }
            return """%s<a href="%s" target="_blank">%s</a>%s""" \
                 % ( what[ :m.start() ],
                     url,
                     url,
                     self.logUrls( who, what[ m.end(): ], when )
                   )
        else:
            return what

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def logWords( self, who, what, when ):
        """log the urls mentioned in a message and link them
        """
        m = self.patterns[ 'word' ].search( what )
        if m:
            cnt = 1
            w =  m.group().lower()
            if self.words.has_key( w ):
                cnt += self.words[ w ][ 'count' ]
            self.words[ w ] = { 'count': cnt,
                                'nick' : who,
                                'time' : when
                              }
            self.logWords( who, what[ m.end(): ], when )

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def incMinute( self, m ):
        """update the byMinute-stats
        """
        m = int( m )
        if not self.byMinute.has_key( m ):
            self.byMinute[ m ] = 0
        self.byMinute[ m ] += 1

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def incHour( self, h ):
        """update the byHour-stats
        """
        h = int( h )
        if not self.byHour.has_key( h ):
            self.byHour[ h ] = 0
        self.byHour[ h ] += 1

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def incDay( self, d ):
        """update the byDay-stats
        """
        d = int( d )-1
        if not self.byDay.has_key( d ):
            self.byDay[ d ] = 0
        self.byDay[ d ] += 1

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def incWeekday( self, w ):
        """update the byWeekday-stats
        """
        w = int( w )
        if not self.byWeekday.has_key( w ):
            self.byWeekday[ w ] = 0
        self.byWeekday[ w ] += 1

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def incMonth( self, m ):
        """update the byMonth-stats
        """
        m = int( m )-1
        if not self.byMonth.has_key( m ):
            self.byMonth[ m ] = 0
        self.byMonth[ m ] += 1

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def incYear( self, y ):
        """update the byYear-stats
        """
        y = int( y )
        if not self.byYear.has_key( y ):
            self.byYear[ y ] = 0
        self.byYear[ y ] += 1

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def nickQuotes( self, who ):
        """return a dictionary of a what a certain nick said
        """
        if who in self.nicks:
            return self.byNick[ who ]

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def randomNickQuote( self, who ):
        """pick a random quote of what a certain nick said
        """
        if who in self.nicks:
            k = self.byNick[ who ].keys()
            k = k[ random.randrange( len( k ) ) ]
            return self.byNick[ who ][ k ]

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def randomNick( self ):
        """randomly select a nick
        """
        if len( self.nicks ) > 0:
            k = self.byNick.keys()
            return k[ random.randrange( len( k ) ) ]

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def randomQuote( self ):
        """pick a totally random quote
        """
        return self.randomNickQuote( self.randomNick() )

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def mostActiveNicks( self, amount=10 ):
        """return a dict of the most active nicks,
           keys are the "activity"-rank
        """
        nicks = {}
        most  = {}
        if amount > len( self.byNick ):
            amount = len( self.byNick )
        if amount > 0:
            # map nick -> no. of posts
            for k, v in self.byNick.items():
                nicks[ k ] = len( v )
            # fetch the first entry
            n = nicks.popitem()
            while n:
                i = len( most )
                if i == 0:
                    # the very first one ;)
                    most[ 1 ] = n
                else:
                    while i > 0:
                        # more posts?
                        if n[ 1 ] > most[ i ][ 1 ]:
                            # copy to next rank
                            if i < amount:
                                most[ i + 1 ] = most[ i ]
                            # new top entry?
                            if i == 1:
                                most[ i ] = n
                            # shift to next
                            i -= 1
                        else:
                            # possibly fill up the empty spaces
                            if i < amount:
                                most[ i+1 ] = n
                            # break
                            i = 0
                # fetch next entry
                if len( nicks ) > 0:
                    n = nicks.popitem()
                else:
                    n = None
        return most

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def mostQuestions( self ):
        """return a dict of the nicks asking the most questions,
           keys are the "activity"-rank
        """
        minMsgs = self.numOfMsgs / len( self.nicks )
        amount  =  2
        nicks   = {}
        most    = {}
        # map nick -> no. of posts
        for k, v in self.questions.items():
            msgs = len( self.byNick[ k ] )
            if msgs > minMsgs:
                nicks[ k ] = 100.0 * v / float( msgs )
        # fetch the first entry
        n = nicks.popitem()
        while n:
            i = len( most )
            if i == 0:
                # the very first one ;)
                most[ 1 ] = n
            else:
                while i > 0:
                    # more posts?
                    if n[ 1 ] > most[ i ][ 1 ]:
                        # copy to next rank
                        if i < amount:
                            most[ i + 1 ] = most[ i ]
                        # new top entry?
                        if i == 1:
                            most[ i ] = n
                        # shift to next
                        i -= 1
                    else:
                        # possibly fill up the empty spaces
                        if i < amount:
                            most[ i+1 ] = n
                        # break
                        i = 0
            # fetch next entry
            if len( nicks ) > 0:
                n = nicks.popitem()
            else:
                n = None
        return most

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def mostYelling( self ):
        """return a dict of the nicks yelling the most,
           keys are the "activity"-rank
        """
        minMsgs = self.numOfMsgs / len( self.nicks )
        amount  =  2
        nicks   = {}
        most    = {}
        # map nick -> no. of posts
        for k, v in self.yelling.items():
            msgs = len( self.byNick[ k ] )
            if msgs > minMsgs:
                nicks[ k ] = 100.0 * v / float( msgs )
        # fetch the first entry
        n = nicks.popitem()
        while n:
            i = len( most )
            if i == 0:
                # the very first one ;)
                most[ 1 ] = n
            else:
                while i > 0:
                    # more posts?
                    if n[ 1 ] > most[ i ][ 1 ]:
                        # copy to next rank
                        if i < amount:
                            most[ i + 1 ] = most[ i ]
                        # new top entry?
                        if i == 1:
                            most[ i ] = n
                        # shift to next
                        i -= 1
                    else:
                        # possibly fill up the empty spaces
                        if i < amount:
                            most[ i+1 ] = n
                        # break
                        i = 0
            # fetch next entry
            if len( nicks ) > 0:
                n = nicks.popitem()
            else:
                n = None
        return most

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def mostShouting( self ):
        """return a dict of the nicks shouting the most,
           keys are the "activity"-rank
        """
        minMsgs = self.numOfMsgs / len( self.nicks )
        amount  =  2
        nicks   = {}
        most    = {}
        # map nick -> no. of posts
        for k, v in self.shouting.items():
            msgs = len( self.byNick[ k ] )
            if msgs > minMsgs:
                nicks[ k ] = 100.0 * v / float( msgs )
        # fetch the first entry
        n = nicks.popitem()
        while n:
            i = len( most )
            if i == 0:
                # the very first one ;)
                most[ 1 ] = n
            else:
                while i > 0:
                    # more posts?
                    if n[ 1 ] > most[ i ][ 1 ]:
                        # copy to next rank
                        if i < amount:
                            most[ i + 1 ] = most[ i ]
                        # new top entry?
                        if i == 1:
                            most[ i ] = n
                        # shift to next
                        i -= 1
                    else:
                        # possibly fill up the empty spaces
                        if i < amount:
                            most[ i+1 ] = n
                        # break
                        i = 0
            # fetch next entry
            if len( nicks ) > 0:
                n = nicks.popitem()
            else:
                n = None
        return most

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def mostHappyFaces( self ):
        """return a dict of the nicks sending the most happy faces,
           keys are the "activity"-rank
        """
        minMsgs = self.numOfMsgs / len( self.nicks )
        amount  =  2
        nicks   = {}
        most    = {}
        # map nick -> no. of posts
        for k, v in self.happy.items():
            msgs = len( self.byNick[ k ] )
            if msgs > minMsgs:
                nicks[ k ] = 100.0 * v / float( msgs )
        # fetch the first entry
        n = nicks.popitem()
        while n:
            i = len( most )
            if i == 0:
                # the very first one ;)
                most[ 1 ] = n
            else:
                while i > 0:
                    # more posts?
                    if n[ 1 ] > most[ i ][ 1 ]:
                        # copy to next rank
                        if i < amount:
                            most[ i + 1 ] = most[ i ]
                        # new top entry?
                        if i == 1:
                            most[ i ] = n
                        # shift to next
                        i -= 1
                    else:
                        # possibly fill up the empty spaces
                        if i < amount:
                            most[ i+1 ] = n
                        # break
                        i = 0
            # fetch next entry
            if len( nicks ) > 0:
                n = nicks.popitem()
            else:
                n = None
        return most

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def mostSadFaces( self ):
        """return a dict of the nicks sending the most sad faces,
           keys are the "activity"-rank
        """
        minMsgs = self.numOfMsgs / len( self.nicks )
        amount  =  2
        nicks   = {}
        most    = {}
        # map nick -> no. of posts
        for k, v in self.sad.items():
            msgs = len( self.byNick[ k ] )
            if msgs > minMsgs:
                nicks[ k ] = 100.0 * v / float( msgs )
        # fetch the first entry
        n = nicks.popitem()
        while n:
            i = len( most )
            if i == 0:
                # the very first one ;)
                most[ 1 ] = n
            else:
                while i > 0:
                    # more posts?
                    if n[ 1 ] > most[ i ][ 1 ]:
                        # copy to next rank
                        if i < amount:
                            most[ i + 1 ] = most[ i ]
                        # new top entry?
                        if i == 1:
                            most[ i ] = n
                        # shift to next
                        i -= 1
                    else:
                        # possibly fill up the empty spaces
                        if i < amount:
                            most[ i+1 ] = n
                        # break
                        i = 0
            # fetch next entry
            if len( nicks ) > 0:
                n = nicks.popitem()
            else:
                n = None
        return most

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def longestLines( self ):
        """return a dict of the nick writing the longest lines
           and the channel average
        """
        minMsgs = self.numOfMsgs / len( self.nicks )
        amount  =  1
        nicks   = {}
        most    = {}
        tc      =  0
        tm      =  0
        # map nick -> no. of posts
        for k, v in self.byNick.items():
            c = 0
            msgs = len( v )
            for l in v.values():
                c += len( l )
            tc += c
            tm += msgs
            if msgs > minMsgs:
                nicks[ k ] = float( c ) / float( msgs )
        # fetch the first entry
        n = nicks.popitem()
        while n:
            i = len( most )
            if i == 0:
                # the very first one ;)
                most[ 1 ] = n
            else:
                while i > 0:
                    # more posts?
                    if n[ 1 ] > most[ i ][ 1 ]:
                        # copy to next rank
                        if i < amount:
                            most[ i + 1 ] = most[ i ]
                        # new top entry?
                        if i == 1:
                            most[ i ] = n
                        # shift to next
                        i -= 1
                    else:
                        # possibly fill up the empty spaces
                        if i < amount:
                            most[ i+1 ] = n
                        # break
                        i = 0
            # fetch next entry
            if len( nicks ) > 0:
                n = nicks.popitem()
            else:
                n = None
        most[ 2 ] = list( ( self.channel, float( tc ) / float( tm ) ) )
        return most

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def wordsPerLine( self ):
        """return a dict of the nick writing the most words per lines
           and the channel average
        """
        minMsgs = self.numOfMsgs / len( self.nicks )
        amount  =  1
        nicks   = {}
        most    = {}
        tw      =  0
        tm      =  0
        # map nick -> no. of posts
        for k, v in self.byNick.items():
            w = 0
            msgs = len( v )
            for l in v.values():
                w += countWords( l )
            tw += w
            tm += msgs
            if msgs > minMsgs:
                nicks[ k ] = float( w ) / float( msgs )
        # fetch the first entry
        n = nicks.popitem()
        while n:
            i = len( most )
            if i == 0:
                # the very first one ;)
                most[ 1 ] = n
            else:
                while i > 0:
                    # more posts?
                    if n[ 1 ] > most[ i ][ 1 ]:
                        # copy to next rank
                        if i < amount:
                            most[ i + 1 ] = most[ i ]
                        # new top entry?
                        if i == 1:
                            most[ i ] = n
                        # shift to next
                        i -= 1
                    else:
                        # possibly fill up the empty spaces
                        if i < amount:
                            most[ i+1 ] = n
                        # break
                        i = 0
            # fetch next entry
            if len( nicks ) > 0:
                n = nicks.popitem()
            else:
                n = None
        most[ 2 ] = list( ( self.channel, float( tw ) / float( tm ) ) )
        return most

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def mostWords( self ):
        """return a dict of the nick who has writtens the most words
           and the channel average
        """
        minMsgs = self.numOfMsgs / len( self.nicks )
        amount  =  1
        nicks   = {}
        most    = {}
        tw      =  0
        tn      =  0
        # map nick -> no. of posts
        for k, v in self.byNick.items():
            w = 0
            for l in v.values():
                w += countWords( l )
            tw += w
            tn += 1
            if len( v ) > minMsgs:
                nicks[ k ] = w
        # fetch the first entry
        n = nicks.popitem()
        while n:
            i = len( most )
            if i == 0:
                # the very first one ;)
                most[ 1 ] = n
            else:
                while i > 0:
                    # more posts?
                    if n[ 1 ] > most[ i ][ 1 ]:
                        # copy to next rank
                        if i < amount:
                            most[ i + 1 ] = most[ i ]
                        # new top entry?
                        if i == 1:
                            most[ i ] = n
                        # shift to next
                        i -= 1
                    else:
                        # possibly fill up the empty spaces
                        if i < amount:
                            most[ i+1 ] = n
                        # break
                        i = 0
            # fetch next entry
            if len( nicks ) > 0:
                n = nicks.popitem()
            else:
                n = None
        most[ 2 ] = list( ( self.channel, float( tw ) / float( tn ) ) )
        return most

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def mostActiveMinutes( self ):
        """which minutes were the most busy ones?
        """
        most     = {}
        scores   = self.byMinute.values()
        scores.sort()
        scores.reverse()
        for k, v in self.byMinute.items():
            most[ scores.index( v )+1 ] = ( k, v )
        return most

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def mostActiveHours( self ):
        """which hours were the most busy ones?
        """
        most     = {}
        scores   = self.byHour.values()
        scores.sort()
        scores.reverse()
        for k, v in self.byHour.items():
            most[ scores.index( v )+1 ] = ( k, v )
        return most

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def mostActiveDays( self ):
        """which days were the most busy ones?
        """
        most     = {}
        scores   = self.byDay.values()
        scores.sort()
        scores.reverse()
        for k, v in self.byDay.items():
            most[ scores.index( v )+1 ] = ( k, v )
        return most

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def mostActiveMonths( self ):
        """which months were the most busy ones?
        """
        most     = {}
        scores   = self.byMonth.values()
        scores.sort()
        scores.reverse()
        for k, v in self.byMonth.items():
            most[ scores.index( v )+1 ] = ( k, v )
        return most

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def mostActiveYears( self ):
        """which years were the most busy ones?
        """
        most     = {}
        scores   = self.byYear.values()
        scores.sort()
        scores.reverse()
        for k, v in self.byYear.items():
            most[ scores.index( v )+1 ] = ( k, v )
        return most

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def mostActiveWeekdays( self ):
        """which weekdays were the most busy ones?
        """
        most     = {}
        scores   = self.byWeekday.values()
        scores.sort()
        scores.reverse()
        for k, v in self.byWeekday.items():
            most[ scores.index( v )+1 ] = ( k, v )
        return most

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def mostReferencedNicks( self, amount=10 ):
        """which nicks were referenced most often?
           (compare to mostActiveNicks)
        """
        nicks = {}
        most  = {}
        if amount > len( self.nickRefs ):
            amount = len( self.nickRefs )
        if amount > 0:
            # map nicks -> no. of references
            for k, v in self.nickRefs.items():
                nicks[ k ] = v[ 'count' ]
            # fetch the first entry
            n = nicks.popitem()
            while n:
                i = len( most )
                if i == 0:
                    # the very first one ;)
                    most[ 1 ] = n
                else:
                    while i > 0:
                        # more references?
                        if n[ 1 ] > most[ i ][ 1 ]:
                            # copy to next rank
                            if i < amount:
                                most[ i + 1 ] = most[ i ]
                            # new top entry?
                            if i == 1:
                                most[ i ] = n
                            # shift to next
                            i -= 1
                        # newer?
                        elif n[ 1 ] == most[ i ][ 1 ] \
                         and self.nickRefs[ n[ 0 ] ][ 'time' ] > self.nickRefs[ most[ i ][ 0 ] ][ 'time' ]:
                            # copy to next rank
                            if i < amount:
                                most[ i + 1 ] = most[ i ]
                            # new top entry?
                            if i == 1:
                                most[ i ] = n
                            # shift to next
                            i -= 1
                        else:
                            # possibly fill up the empty spaces
                            if i < amount:
                                most[ i+1 ] = n
                            # break
                            i = 0
                # fetch next entry
                if len( nicks ) > 0:
                    n = nicks.popitem()
                else:
                    n = None
        return most

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def mostReferencedUrls( self, amount=10 ):
        """which urls were referenced most often?
           (compare to mostActiveNicks)
        """
        urls = {}
        most  = {}
        if amount > len( self.urls ):
            amount = len( self.urls )
        if amount > 0:
            # map urls -> no. of references
            for k, v in self.urls.items():
                urls[ k ] = v[ 'count' ]
            # fetch the first entry
            u = urls.popitem()
            while u:
                i = len( most )
                if i == 0:
                    # the very first one ;)
                    most[ 1 ] = u
                else:
                    while i > 0:
                        # more references?
                        if u[ 1 ] > most[ i ][ 1 ]:
                            # copy to next rank
                            if i < amount:
                                most[ i + 1 ] = most[ i ]
                            # new top entry?
                            if i == 1:
                                most[ i ] = u
                            # shift to next
                            i -= 1
                        # newer?
                        elif u[ 1 ] == most[ i ][ 1 ] \
                         and self.urls[ u[ 0 ] ][ 'time' ] > self.urls[ most[ i ][ 0 ] ][ 'time' ]:
                            # copy to next rank
                            if i < amount:
                                most[ i + 1 ] = most[ i ]
                            # new top entry?
                            if i == 1:
                                most[ i ] = u
                            # shift to next
                            i -= 1
                        else:
                            # possibly fill up the empty spaces
                            if i < amount:
                                most[ i+1 ] = u
                            # break
                            i = 0
                # fetch next entry
                if len( urls ) > 0:
                    u = urls.popitem()
                else:
                    u = None
        return most

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def mostUsedWords( self, amount=10 ):
        """which words were used most often?
           (compare to mostActiveNicks)
        """
        words = {}
        most  = {}
        if amount > len( self.words ):
            amount = len( self.words )
        if amount > 0:
            # map words -> no. of references
            for k, v in self.words.items():
                words[ k ] = v[ 'count' ]
            # fetch the first entry
            w = words.popitem()
            while w:
                i = len( most )
                if i == 0:
                    # the very first one ;)
                    most[ 1 ] = w
                else:
                    while i > 0:
                        # more references?
                        if w[ 1 ] > most[ i ][ 1 ]:
                            # copy to next rank
                            if i < amount:
                                most[ i + 1 ] = most[ i ]
                            # new top entry?
                            if i == 1:
                                most[ i ] = w
                            # shift to next
                            i -= 1
                        # newer?
                        elif w[ 1 ] == most[ i ][ 1 ] \
                         and self.words[ w[ 0 ] ][ 'time' ] > self.words[ most[ i ][ 0 ] ][ 'time' ]:
                            # copy to next rank
                            if i < amount:
                                most[ i + 1 ] = most[ i ]
                            # new top entry?
                            if i == 1:
                                most[ i ] = w
                            # shift to next
                            i -= 1
                        else:
                            # possibly fill up the empty spaces
                            if i < amount:
                                most[ i+1 ] = w
                            # break
                            i = 0
                # fetch next entry
                if len( words ) > 0:
                    w = words.popitem()
                else:
                    w = None
        return most


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #



class ircLogHtml( ircLog ):
    """a derived irc log-analyzer printing out html
    """

    def __init__( self, channel, network, generator, path=None ):
        """see ircLog
        """
        ircLog.__init__( self, channel, network, generator, path )

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def nickActivity( self, nick ):
        """print out a graph of a nicks most active hours
        """
        msgs = self.nickQuotes( nick )
        if msgs:
            activity = {}
            average  = self.numOfMsgs / len( self.nicks ) / 24 / daysDiffMyTime( self.firstMsg, self.lastMsg )
            for i in range( 24 ):
                activity[ i ] = 0
            total = len( msgs )
            for k in msgs.keys():
                activity[ int( k[ 8:10 ] ) ] += 1
#            html = """
#<table align="center" border="0" cellpadding="0" cellspacing="0">

#    <tr>
#"""
            for i in range( 24 ):
                h = activity[ i ] / (average+1)

                activity[ i ] = h
            return """
<img src="%s" alt="" border="0" height="20" width="48" />
""" % nickActivity( self.channel, nick, activity )

#                if i > 0:
#                    l = ( activity[ i ] + activity[ i-1 ] ) * 10 / total
#                    html += """
#        <td align="center" class="data" valign="bottom"><table align="center" border="0" cellpadding="0" cellspacing="0" width="1">
#                <tr>
#                    <td align="center" class="header_1"><img src="/gfx/pixel.gif" alt="" border="0" height="%d" width="1" /></td>
#                </tr>
#            </table></td>
#""" % math.ceil( l + 2 )
#                html += """
#        <td align="center" class="data" valign="bottom"><table align="center" border="0" cellpadding="0" cellspacing="0" width="1">
#                <tr>

#                    <td align="center" class="header_3"><img src="/gfx/pixel.gif" alt="" border="0" height="%d" width="1" /></td>
#                </tr>
#            </table></td>
#""" % math.ceil( h + 2 )
#            return html + """
#    </tr>
#</table>
#"""


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def mostActiveNicks( self, amount=10 ):
        """see ircLog
        """
        html = []
        if amount > len( self.nicks ):
            amount = len( self.nicks )
        html.append( """
<table align="center" border="0" cellpadding="0" cellspacing="0" width="100%%">
    <tr>
        <th align="center" class="header_2" colspan="9">
%d &nbsp; M O S T &nbsp; A C T I V E &nbsp; N I C K S
        </th>

    </tr>
    <tr>
        <th align="center" class="header_3" width="15">#</th>
        <td align="center" class="border_2" width="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
        <th align="center" class="header_3">Nick</th>
        <td align="center" class="border_2" width="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
        <th align="center" class="header_3" width="50">Posts</th>

        <td align="center" class="border_2" width="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
        <th align="center" class="header_3" width="50">Activity</th>
        <td align="center" class="border_2" width="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
        <th align="center" class="header_3">Random Quote</th>
    </tr>
""" % amount )
        for k, v in ircLog.mostActiveNicks( self, amount ).items():
            html.append( """
    <tr>
        <td align="center" class="border_2" colspan="9" height="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
    </tr>

    <tr>
        <td align="right" class="data" valign="top">%d.</td>
        <td align="center" class="border_3" width="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
        <td align="left" class="data" valign="top">%s</td>
        <td align="center" class="border_3" width="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
        <td align="right" class="data" valign="top">%d</td>
        <td align="center" class="border_3" width="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>

        <td align="center" class="data" valign="middle">%s</td>
        <td align="center" class="border_3" width="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
    <td align="left" class="data" valign="top"><i>%s</i></td>
    </tr>
""" % ( k, v[0], v[1], self.nickActivity( v[0] ), ircLog.randomNickQuote( self, v[0] ) ) )
        html.append( "</table>" )
        return ''.join( html )

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def notSoActiveNicks( self, amount=50, offset=10 ):
        """prints a list of nicks and the number of their messages,
           optionally an offset can be provided
        """
        html = []
        if amount+offset > len( self.nicks ):
            if offset > len( self.nicks ):
                amount = 0
            else:
                amount = len( self.nicks )-offset
        html.append( """
<table align="center" border="0" cellpadding="0" cellspacing="0" width="100%%">
    <tr>
        <th align="center" class="header_2" colspan="9">

%d &nbsp; N O T &nbsp; SO &nbsp; A C T I V E &nbsp; N I C K S
        </th>
    </tr>
    <tr>
        <td align="center" class="border_2" colspan="9" height="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
    </tr>

""" % amount )
        i = 0
        for k, v in ircLog.mostActiveNicks( self, amount+offset ).items():
            if k > offset:
                if i % 5 == 0:
                    html.append( """
    <tr>
""" )
                else:
                    html.append( """
        <td align="center" class="border_3" width="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
""" )
                html.append( """
        <td align="left" class="data" valign="top">
%s (%d)
        </td>
""" % ( v[0], v[1] ) )
                if i % 5 == 4:
                    html.append( """
    </tr>
""" )
                i += 1
        if i > 0:
            if i % 5 < 4:
                html.append( """
        <td align="center" class="border_3" width="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
""" )
                if i % 5 == 3:
                    html.append( """
            <td align="center" class="data" valign="top">
            </td>
""" )
                else:
                    html.append( """
            <td align="center" class="data" colspan="%d" valign="top">
            </td>
""" % ( ( 5 - ( i % 5 ) ) * 2 - 1 ) )
                html.append( """
        </tr>
""" )
        else:
            html.append( """
        <tr>
            <td align="center" class="data" colspan="9" valign="top">
not enough nicks visited this channel
            </td>
        </tr>
""" )
        html.append( "</table>" )
        return ''.join( html )

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def mostQuestions( self ):
        """see ircLog
        """
        q = ircLog.mostQuestions( self )
        return """
<table align="center" border="0" cellpadding="0" cellspacing="0" width="100%%">
    <tr>
        <th align="left" class="data" valign="top">
Is %s stupid or just asking too many questions? %.1f%% of his/her messages contained a question.
        </th>
    </tr>
    <tr>
        <td align="left" class="data" valign="top">
%s didn't know much either - %.1f%% of his/her lines were questions.
        </td>

    </tr>
</table>
""" % ( q[ 1 ][ 0 ], q[ 1 ][ 1 ], q[ 2 ][ 0 ], q[ 2 ][ 1 ] )

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def mostYelling( self ):
        """see ircLog
        """
        y = ircLog.mostYelling( self )
        return """
<table align="center" border="0" cellpadding="0" cellspacing="0" width="100%%">
    <tr>
        <th align="left" class="data" valign="top">
The loudest one was %s, who yelled %.1f%% of the time!
        </th>
    </tr>
    <tr>
        <td align="left" class="data" valign="top">

Another old yeller was %s, who shouted %.1f%% of the time!
        </td>
    </tr>
</table>
""" % ( y[ 1 ][ 0 ], y[ 1 ][ 1 ], y[ 2 ][ 0 ], y[ 2 ][ 1 ] )

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def mostShouting( self ):
        """see ircLog
        """
        s = ircLog.mostShouting( self )
        return """
<table align="center" border="0" cellpadding="0" cellspacing="0" width="100%%">
    <tr>
        <th align="left" class="data" valign="top">
It seems that %s's shift-key is hanging: %.1f%% of the time he/she wrote UPPERCASE.
        </th>
    </tr>
    <tr>

        <td align="left" class="data" valign="top">
%s just forgot to deactivate his/her Caps-Lock. He/She wrote UPPERCASE %.1f%% of the time.
        </td>
    </tr>
</table>
""" % ( s[ 1 ][ 0 ], s[ 1 ][ 1 ], s[ 2 ][ 0 ], s[ 2 ][ 1 ] )

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def mostHappyFaces( self ):
        """see ircLog
        """
        h = ircLog.mostHappyFaces( self )
        return """
<table align="center" border="0" cellpadding="0" cellspacing="0" width="100%%">
    <tr>
        <th align="left" class="data" valign="top">
%s brings happiness to the world. %.1f%% lines contained smiling faces. :)
        </th>
    </tr>

    <tr>
        <td align="left" class="data" valign="top">
%s isn't a sad person either, smiling %.1f%% of the time.
        </td>
    </tr>
</table>
""" % ( h[ 1 ][ 0 ], h[ 1 ][ 1 ], h[ 2 ][ 0 ], h[ 2 ][ 1 ] )

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def mostSadFaces( self ):
        """see ircLog
        """
        s = ircLog.mostSadFaces( self )
        return """
<table align="center" border="0" cellpadding="0" cellspacing="0" width="100%%">
    <tr>
        <th align="left" class="data" valign="top">
%s seems to be sad at the moment: %.1f%% lines contained sad faces. :(
        </th>

    </tr>
    <tr>
        <td align="left" class="data" valign="top">
%s is also a sad person, crying %.1f%% of the time.
        </td>
    </tr>
</table>
""" % ( s[ 1 ][ 0 ], s[ 1 ][ 1 ], s[ 2 ][ 0 ], s[ 2 ][ 1 ] )

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def longestLines( self ):
        """see ircLog
        """
        l = ircLog.longestLines( self )
        return """
<table align="center" border="0" cellpadding="0" cellspacing="0" width="100%%">
    <tr>
        <th align="left" class="data" valign="top">

%s wrote the longest lines, averaging %.1f letters per line.
        </th>
    </tr>
    <tr>
        <td align="left" class="data" valign="top">
%s average was %.1f letters per line.
        </td>
    </tr>
</table>
""" % ( l[ 1 ][ 0 ], l[ 1 ][ 1 ], l[ 2 ][ 0 ], l[ 2 ][ 1 ] )

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def wordsPerLine( self ):
        """see ircLog
        """
        w = ircLog.wordsPerLine( self )
        return """
<table align="center" border="0" cellpadding="0" cellspacing="0" width="100%%">
    <tr>

        <th align="left" class="data" valign="top">
%s wrote the most words per lines, averaging %.1f words per line.
        </th>
    </tr>
    <tr>
        <td align="left" class="data" valign="top">
%s average was %.1f words per line.
        </td>
    </tr>
</table>
""" % ( w[ 1 ][ 0 ], w[ 1 ][ 1 ], w[ 2 ][ 0 ], w[ 2 ][ 1 ] )

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def mostWords( self ):
        """see ircLog
        """
        w = ircLog.mostWords( self )
        return """
<table align="center" border="0" cellpadding="0" cellspacing="0" width="100%%">

    <tr>
        <th align="left" class="data" valign="top">
%s had the most to say - he/she used %d words.
        </th>
    </tr>
    <tr>
        <td align="left" class="data" valign="top">
the average %s visitor used %.1f words.
        </td>
    </tr>
</table>

""" % ( w[ 1 ][ 0 ], w[ 1 ][ 1 ], w[ 2 ][ 0 ], w[ 2 ][ 1 ] )

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def interestingNumbers( self ):
        """a bunch of interesting numbers
        """
        s = ircLog.mostSadFaces( self )
        return """
<table align="center" border="0" cellpadding="0" cellspacing="0" width="100%%">
    <tr>
        <th align="center" class="header_2">
S O M E &nbsp; I N T E R E S T I N G &nbsp; N U M B E R S
        </th>
    </tr>
    <tr>
        <td align="center" class="border_2" height="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>

    </tr>
    <tr>
        <td align="center" class="data" valign="top">
%s
        </td>
    </tr>
</table>
""" % ( self.mostQuestions() + self.mostYelling() + self.mostShouting()
      + self.mostHappyFaces() + self.mostSadFaces()
      + self.longestLines() + self.wordsPerLine() + self.mostWords()
      )

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def randomNick( self ):
        """see ircLog
        """
        return """
<table align="center" border="0" cellpadding="0" cellspacing="0" width="100%%">
    <tr>
        <th align="right" width="100">Random Nick:</th>
        <td align="left">%s</td>
    </tr>
</table>
""" % ircLog.randomNick( self )

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def randomQuote( self ):
        """see ircLog
        """
        return """
<table align="center" border="0" cellpadding="0" cellspacing="0" width="100%%">
    <tr>
        <th align="right" width="100">Random Quote:</th>
        <td align="left">%s</td>
    </tr>
</table>
""" % ircLog.randomQuote( self )

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def mostActiveWeekdays( self ):
        """see ircLog
        """
        html = []
        html.append( """
<table align="center" border="0" cellpadding="0" cellspacing="0" width="100%">
    <tr>
        <th align="center" class="header_2" colspan="13">
M O S T &nbsp; A C T I V E &nbsp; W E E K D A Y S
        </th>
    </tr>
    <tr>
        <td align="center" class="border_2" colspan="13" height="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
    </tr>
    <tr>
""" )
        total = 0
        most  = ircLog.mostActiveWeekdays( self )[ 1 ][ 0 ]
        for d in range( 7 ):
            total += self.byWeekday[ d ]
        for d in range( 7 ):
            if d > 0:
                html.append( """
        <td align="center" class="border_3" width="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
""" )
            percentage = 100.0 * self.byWeekday[ d ] / total
            html.append( """
        <td align="center" class="data" valign="bottom">
            <table align="center" border="0" cellpadding="0" cellspacing="0">
                <tr>
                    <td align="center">%.1f %%</td>
                </tr>
                <tr>
                    <td align="center" valign="bottom">
                        <table align="center" border="0" cellpadding="0" cellspacing="0" width="50%%">
                            <tr>
                                <td align="center" class="header_3"><img src="/gfx/pixel.gif" alt="" border="0" height="%d" width="1" /></td>
                            </tr>
                        </table>
                    </td>

                </tr>
            </table>
        </td>
""" % ( percentage, math.ceil( percentage ) ) )

        html.append( """
    </tr>
    <tr>
        <td align="center" class="border_2" colspan="13" height="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
    </tr>
    <tr>
""" )
        for d in range( 7 ):
            bgcolor = 'data'
            if d == most:
                bgcolor = 'header_3'
            if d > 0:
                html.append( """
        <td align="center" class="border_3" width="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
""" )
            html.append( """
        <td align="center" class="%s">%s</td>
""" % ( bgcolor, weekdayNames[ d ] ) )

        html.append( """
    </tr>
</table>
""" )
        return ''.join( html )

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def mostActiveMinutes( self ):
        """see ircLog
        """
        html = []
        html.append( """
<table align="center" border="0" cellpadding="0" cellspacing="0" width="100%">
    <tr>
        <th align="center" class="header_2" colspan="119">
M O S T &nbsp; A C T I V E &nbsp; M I N U T E S
        </th>
    </tr>
    <tr>
        <td align="center" class="border_2" colspan="119" height="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
    </tr>
    <tr>
""" )
        total = 0
        most  = ircLog.mostActiveMinutes( self )[ 1 ][ 0 ]
        for m in range( 60 ):
            total += self.byMinute[ m ]
        for m in range( 60 ):
            percentage = 100.0 * self.byMinute[ m ] / total
            if m > 0:
                html.append( """
        <td align="center" class="border_3" width="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
""" )
            html.append( """
        <td align="center" class="data" valign="bottom">
            <table align="center" border="0" cellpadding="0" cellspacing="0">
                <tr>
                    <td align="center" valign="bottom">
                        <table align="center" border="0" cellpadding="0" cellspacing="0" width="50%%">
                            <tr>
                                <td align="center" class="header_3"><img src="/gfx/pixel.gif" alt="" border="0" height="%d" width="1" /></td>
                            </tr>
                        </table>
                    </td>
                </tr>
            </table>
        </td>
""" % ( math.ceil( percentage ) ) )

        html.append( """
    </tr>
    <tr>
        <td align="center" class="border_2" colspan="119" height="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
    </tr>
    <tr>
""" )
        for m in range( 60 ):
            bgcolor = 'data'
            if m == most:
                bgcolor = 'header_3'
            if m > 0:
                html.append( """
        <td align="center" class="border_3" width="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
""" )
            html.append( """
        <td align="center" class="%s">%s</td>
""" % ( bgcolor, m ) )

        html.append( """
    </tr>
</table>
""" )
        return ''.join( html )

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def mostActiveHours( self ):
        """see ircLog
        """
        html = []
        html.append( """
<table align="center" border="0" cellpadding="0" cellspacing="0" width="100%">
    <tr>
        <th align="center" class="header_2" colspan="47">
M O S T &nbsp; A C T I V E &nbsp; H O U R S
        </th>
    </tr>
    <tr>
        <td align="center" class="border_2" colspan="47" height="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
    </tr>
    <tr>
""" )
        total = 0
        most  = ircLog.mostActiveHours( self )[ 1 ][ 0 ]
        for h in range( 24 ):
            total += self.byHour[ h ]
        for h in range( 24 ):
            percentage = 100.0 * self.byHour[ h ] / total
            if h > 0:
                html.append( """
        <td align="center" class="border_3" width="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
""" )
            html.append( """
        <td align="center" class="data" valign="bottom">
            <table align="center" border="0" cellpadding="0" cellspacing="0">
                <tr>
                    <td align="center">%.1f %%</td>
                </tr>
                <tr>
                    <td align="center" valign="bottom">
                        <table align="center" border="0" cellpadding="0" cellspacing="0" width="50%%">
                            <tr>
                                <td align="center" class="header_3"><img src="/gfx/pixel.gif" alt="" border="0" height="%d" width="1" /></td>
                            </tr>
                        </table>
                    </td>
                </tr>
            </table>
        </td>
""" % ( percentage, math.ceil( percentage ) ) )

        html.append( """
    </tr>
    <tr>
        <td align="center" class="border_2" colspan="47" height="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
    </tr>
    <tr>
""" )
        for h in range( 24 ):
            bgcolor = 'data'
            if h == most:
                bgcolor = 'header_3'
            if h > 0:
                html.append( """
        <td align="center" class="border_3" width="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
""" )
            html.append( """
        <td align="center" class="%s">%s</td>
""" % ( bgcolor, h ) )

        html.append( """
    </tr>
</table>
""" )
        return ''.join( html )

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def mostActiveDays( self ):
        """see ircLog
        """
        html = []
        html.append( """
<table align="center" border="0" cellpadding="0" cellspacing="0" width="100%">
    <tr>
        <th align="center" class="header_2" colspan="61">
M O S T &nbsp; A C T I V E &nbsp; D A Y S
        </th>
    </tr>
    <tr>
        <td align="center" class="border_2" colspan="61" height="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
    </tr>
    <tr>
""" )
        total = 0
        most  = ircLog.mostActiveDays( self )[ 1 ][ 0 ]
        for d in range( 31 ):
            total += self.byDay[ d ]
        for d in range( 31 ):
            percentage = 100.0 * self.byDay[ d ] / total
            if d > 0:
                html.append( """
        <td align="center" class="border_3" width="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
""" )
            html.append( """
        <td align="center" class="data" valign="bottom">
            <table align="center" border="0" cellpadding="0" cellspacing="0">
                <tr>
                    <td align="center">%.1f %%</td>
                </tr>
                <tr>
                    <td align="center" valign="bottom">
                        <table align="center" border="0" cellpadding="0" cellspacing="0" width="50%%">
                            <tr>
                                <td align="center" class="header_3"><img src="/gfx/pixel.gif" alt="" border="0" height="%d" width="1" /></td>
                            </tr>
                        </table>
                    </td>
                </tr>
            </table>
        </td>
""" % ( percentage, math.ceil( percentage ) ) )

        html.append( """
    </tr>
    <tr>
        <td align="center" class="border_2" colspan="61" height="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
    </tr>
    <tr>
""" )
        for d in range( 31 ):
            bgcolor = 'data'
            if d == most:
                bgcolor = 'header_3'
            if d > 0:
                html.append( """
        <td align="center" class="border_3" width="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
""" )
            html.append( """
        <td align="center" class="%s">%s</td>
""" % ( bgcolor, d ) )

        html.append( """
    </tr>
</table>
""" )
        return ''.join( html )

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def mostActiveMonths( self ):
        """see ircLog
        """
        html = []
        html.append( """
<table align="center" border="0" cellpadding="0" cellspacing="0" width="100%">
    <tr>
        <th align="center" class="header_2" colspan="23">
M O S T &nbsp; A C T I V E &nbsp; M O N T H S
        </th>
    </tr>
    <tr>
        <td align="center" class="border_2" colspan="23" height="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
    </tr>
    <tr>
""" )
        total = 0
        most  = ircLog.mostActiveMonths( self )[ 1 ][ 0 ]
        for m in range( 12 ):
            total += self.byMonth[ m ]
        for m in range( 12 ):
            percentage = 100.0 * self.byMonth[ m ] / total
            if m > 0:
                html.append( """
        <td align="center" class="border_3" width="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
""" )
            html.append( """
        <td align="center" class="data" valign="bottom">
            <table align="center" border="0" cellpadding="0" cellspacing="0">
                <tr>
                    <td align="center">%.1f %%</td>
                </tr>
                <tr>
                    <td align="center" valign="bottom">
                        <table align="center" border="0" cellpadding="0" cellspacing="0" width="50%%">
                            <tr>
                                <td align="center" class="header_3"><img src="/gfx/pixel.gif" alt="" border="0" height="%d" width="1" /></td>
                            </tr>
                        </table>
                    </td>
                </tr>
            </table>
        </td>
""" % ( percentage, math.ceil( percentage ) ) )

        html.append( """
    </tr>
    <tr>
        <td align="center" class="border_2" colspan="23" height="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
    </tr>
    <tr>
""" )
        for m in range( 12 ):
            bgcolor = 'data'
            if m == most:
                bgcolor = 'header_3'
            if m > 0:
                html.append( """
        <td align="center" class="border_3" width="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
""" )
            html.append( """
        <td align="center" class="%s">%s</td>
""" % ( bgcolor, monthNames[ m ] ) )

        html.append( """
    </tr>
</table>
""" )
        return ''.join( html )

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def mostReferencedNicks( self, amount=10 ):
        """see ircLog
        """
        html = []
        if amount > len( self.nickRefs ):
            amount = len( self.nickRefs )
        html.append( """
<table align="center" border="0" cellpadding="0" cellspacing="0" width="100%%">
    <tr>
        <th align="center" class="header_2" colspan="9">
%d &nbsp; M O S T &nbsp; R E F E R E N C E D &nbsp; N I C K S
        </th>
    </tr>
    <tr>
        <th align="center" class="header_3" width="15">#</th>
        <td align="center" class="border_2" width="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
        <th align="center" class="header_3">Nick</th>
        <td align="center" class="border_2" width="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
        <th align="center" class="header_3" width="25">Ref's</th>
        <td align="center" class="border_2" width="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
        <th align="center" class="header_3" width="175">Last Referenced By</th>
        <td align="center" class="border_2" width="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
        <th align="center" class="header_3" width="200">When</th>
    </tr>
""" % amount )
        for k, v in ircLog.mostReferencedNicks(self, amount ).items():
            html.append( """
    <tr>
        <td align="center" class="border_2" colspan="9" height="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
    </tr>
    <tr>
        <td align="right" class="data" valign="top" width="15">%d.</td>
        <td align="center" class="border_3" width="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
        <td align="left" class="data" valign="top">%s</td>
        <td align="center" class="border_3" width="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
        <td align="right" class="data" valign="top" width="25">%d</td>
        <td align="center" class="border_3" width="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
        <td align="left" class="data" valign="top" width="175">%s</td>
        <td align="center" class="border_3" width="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
        <td align="right" class="data" valign="top" width="200">%s</td>
    </tr>
""" % ( k, v[0], v[1], self.nickRefs[ v[0] ][ 'nick' ], formatMyTime( self.nickRefs[ v[0] ][ 'time' ] ) ) )
        html.append( "</table>" )
        return ''.join( html )

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def mostReferencedUrls( self, amount=10 ):
        """see ircLog
        """
        html = []
        if amount > len( self.urls ):
            amount = len( self.urls )
        html.append( """
<table align="center" border="0" cellpadding="0" cellspacing="0" width="100%%">
    <tr>
        <th align="center" class="header_2" colspan="9">
%d &nbsp; M O S T &nbsp; R E F E R E N C E D &nbsp; U R L S
        </th>
    </tr>
    <tr>
        <th align="center" class="header_3" width="15">#</th>
        <td align="center" class="border_2" width="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
        <th align="center" class="header_3">Url</th>
        <td align="center" class="border_2" width="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
        <th align="center" class="header_3" width="25">Ref's</th>
        <td align="center" class="border_2" width="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
        <th align="center" class="header_3" width="175">Last Referenced By</th>
        <td align="center" class="border_2" width="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
        <th align="center" class="header_3" width="200">When</th>
    </tr>
""" % amount )
        for k, v in ircLog.mostReferencedUrls( self, amount ).items():
            html.append( """
    <tr>
        <td align="center" class="border_2" colspan="9" height="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
    </tr>
    <tr>
        <td align="right" class="data" valign="top" width="15">%d.</td>
        <td align="center" class="border_3" width="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
        <td align="left" class="data" valign="top"><a href="%s" target="_blank">%s</a></td>
        <td align="center" class="border_3" width="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
        <td align="right" class="data" valign="top" width="25">%d</td>
        <td align="center" class="border_3" width="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
        <td align="left" class="data" valign="top" width="175">%s</td>
        <td align="center" class="border_3" width="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
        <td align="right" class="data" valign="top" width="200">%s</td>
    </tr>
""" % ( k, v[0], v[0][:75], v[1], self.urls[ v[0] ][ 'nick' ], formatMyTime( self.urls[ v[0] ][ 'time' ] ) ) )
        html.append( "</table>" )
        return ''.join( html )

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def mostUsedWords( self, amount=10 ):
        """see ircLog
        """
        html = []
        if amount > len( self.words ):
            amount = len( self.words )
        html.append( """
<table align="center" border="0" cellpadding="0" cellspacing="0" width="100%%">
    <tr>
        <th align="center" class="header_2" colspan="9">
%d &nbsp; M O S T &nbsp; U S E D &nbsp; W O R D S
        </th>
    </tr>
    <tr>
        <th align="center" class="header_3" width="15">#</th>
        <td align="center" class="border_2" width="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
        <th align="center" class="header_3">Word</th>
        <td align="center" class="border_2" width="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
        <th align="center" class="header_3" width="25">Uses</th>
        <td align="center" class="border_2" width="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
        <th align="center" class="header_3" width="175">Last Used By</th>
        <td align="center" class="border_2" width="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
        <th align="center" class="header_3" width="200">When</th>
    </tr>
""" % amount )
        for k, v in ircLog.mostUsedWords( self, amount ).items():
            html.append( """
    <tr>
        <td align="center" class="border_2" colspan="9" height="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
    </tr>
    <tr>
        <td align="right" class="data" valign="top" width="15">%d.</td>
        <td align="center" class="border_3" width="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
        <td align="left" class="data" valign="top">%s</td>
        <td align="center" class="border_3" width="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
        <td align="right" class="data" valign="top" width="25">%d</td>
        <td align="center" class="border_3" width="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
        <td align="left" class="data" valign="top" width="175">%s</td>
        <td align="center" class="border_3" width="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
        <td align="right" class="data" valign="top" width="200">%s</td>
    </tr>
""" % ( k, v[0], v[1], self.words[ v[0] ][ 'nick' ], formatMyTime( self.words[ v[0] ][ 'time' ] ) ) )
        html.append( "</table>" )
        return ''.join( html )

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def printPluginBox( self, content ):
        """print a "boy" around a content (e.g. a plugin)
        """
        return """
    <tr>
        <td align="center">
    %s
        </td>
    </tr>
    <tr>
        <td align="center" class="border_1" height="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
    </tr>
""" % content

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    def __repr__( self ):
        """the represantation as a string
        """
        html = []
        html.append( """
<html>
    <head>
        <title>stats for %s on %s - generated by %s</title>
        <style>
<!--
.data{
    background-color: #222222;
    color           : #aaaaaa;
}
.header_1{
    background-color: #444444;
    color           : #cccccc;
}
.header_2{
    background-color: #666666;
    color           : #222222;
}
.header_3{
    background-color: #888888;
    color           : #444444;
}
.border_1{
    background-color: #cccccc;
}
.border_2{
    background-color: #888888;
}
.border_3{
    background-color: #444444;
}
-->
        </style>
    </head>
    <body bgcolor="#000000" text="#aaaaaa" link="#ffffee" alink="#ffffee" vlink="#ffffee">
<table align="center" border="0" cellpadding="0" cellspacing="0" width="100%%">
    <tr>
        <td align="center" class="border_1" rowspan="21" width="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
        <td align="center" class="border_1" height="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
        <td align="center" class="border_1" rowspan="21" width="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
    </tr>
    <tr>
        <th align="center" class="header_1">
stats for %s on %s - generated by %s
        </th>
    </tr>
    <tr>
        <td align="center" class="border_1" height="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
    </tr>
""" % ( self.channel, self.network, self.generator,
        self.channel, self.network, self.generator
      ) )
        html.append( """
    <tr>
        <td align="center" class="header_3">
<p>
during this <b>%d</b>-day period <b>%d</b> different nicks visited %s
</p>
        </td>
    </tr>
    <tr>
        <td align="center" class="border_1" height="1"><img src="/gfx/pixel.gif" alt="" border="0" height="1" width="1" /></td>
    </tr>
""" % ( daysDiffMyTime( self.firstMsg, self.lastMsg ), len( self.nicks ), self.channel ) )
        # process the plugins
#        html.append(  self.printPluginBox( self.mostActiveMinutes() ) )
        html.append( self.printPluginBox( self.mostActiveHours() ) )
#        html.append( self.printPluginBox( self.mostActiveDays() ) )
#        html.append( self.printPluginBox( self.mostActiveMonths() ) )
        html.append( self.printPluginBox( self.mostActiveWeekdays() ) )
        html.append( self.printPluginBox( self.mostActiveNicks( 25 ) ) )
        html.append( self.printPluginBox( self.notSoActiveNicks( 50, 25 ) ) )
        html.append( self.printPluginBox( self.interestingNumbers() ) )
        html.append( self.printPluginBox( self.mostUsedWords( 10 ) ) )
        html.append( self.printPluginBox( self.mostReferencedNicks( 10 ) ) )
        html.append( self.printPluginBox( self.mostReferencedUrls( 25 ) ) )

        duration = int( time.time() - self.startTime )

        html.append( """
</table>
<p align="center">
    %d messages were processed in %d hours %d minutes %d seconds
    <br />

    last update: %s
    <br />
    <a href="http://pils.berlios.de"><img src="powered_by_pils.png" alt="powered by PILS - Python Irc Log Stats" border="0" height="64" width="192" /></a>
</p>
""" % ( self.numOfMsgs,
        int( math.floor( duration / 3600 ) ),
        int( math.floor( duration / 60 ) ),
        int( math.floor( duration % 60 ) ),
        time.ctime()
      ) )
        return ''.join( html )


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

#only execute this if called directly
if __name__ == "__main__":

    # check parameter count
    if len( sys.argv[ 1: ] ) < 5:
        print """
ERROR: not enough parameters
usage: %s channel network generator input output
""" % sys.argv[ 0 ]
        sys.exit( 1 )

    # check if input file exists
    if not os.path.exists( sys.argv[ 4 ] ):
        print """
ERROR: input file does not exist
usage: %s input output
""" % sys.argv[ 0 ]
        sys.exit( 1 )

    # check if directory for output file exists
    if not os.path.exists( os.path.dirname( sys.argv[ 5 ] ) ):
        print """
ERROR: directory for output file does not exist
usage: %s input output
""" % sys.argv[ 0 ]
        sys.exit( 1 )

    #   #   #   #   #

    # initialise the randomizer
    random.seed()

    # read in the logfile
    il = ircLogHtml( sys.argv[ 1 ], sys.argv[ 2 ], sys.argv[ 3 ], sys.argv[ 4 ] )

    # generate some output
    out = open( sys.argv[ 5 ], "w" )
    out.write( str( il ) )
    out.close()

### eof ###
